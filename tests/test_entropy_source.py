"""Tests for qc_sampler.entropy_source.

Covers:
- OsUrandomSource: correct byte count, health check
- MockUniformSource: configurable mean, reproducibility with seed
- FallbackEntropySource: falls back on EntropyUnavailableError only
- FallbackEntropySource: propagates other exceptions unchanged
- GrpcEntropySource: not tested here (requires gRPC server); tested
  indirectly via FallbackEntropySource wrapper pattern
"""

from __future__ import annotations

from unittest.mock import MagicMock

import numpy as np
import pytest

from qc_sampler.entropy_source import (
    EntropySource,
    FallbackEntropySource,
    MockUniformSource,
    OsUrandomSource,
)
from qc_sampler.exceptions import EntropyUnavailableError


# ---------------------------------------------------------------------------
# OsUrandomSource
# ---------------------------------------------------------------------------


class TestOsUrandomSource:
    """Tests for the os.urandom-based entropy source."""

    def test_returns_correct_byte_count(self) -> None:
        """get_bytes must return exactly the requested number of bytes."""
        source = OsUrandomSource()
        for count in (1, 100, 20480):
            data = source.get_bytes(count)
            assert len(data) == count
            assert isinstance(data, bytes)

    def test_returns_different_data(self) -> None:
        """Successive calls should return different data (probabilistic)."""
        source = OsUrandomSource()
        a = source.get_bytes(1000)
        b = source.get_bytes(1000)
        # Extremely unlikely to be identical for 1000 random bytes.
        assert a != b

    def test_health_check(self) -> None:
        """Health check should report healthy with correct source name."""
        source = OsUrandomSource()
        health = source.health_check()
        assert health["source"] == "os_urandom"
        assert health["healthy"] is True

    def test_prefetch_is_noop(self) -> None:
        """Prefetch should not raise — it's a no-op."""
        source = OsUrandomSource()
        source.prefetch(20480)  # Should not raise


# ---------------------------------------------------------------------------
# MockUniformSource
# ---------------------------------------------------------------------------


class TestMockUniformSource:
    """Tests for the mock entropy source with configurable mean."""

    def test_returns_correct_byte_count(self) -> None:
        """get_bytes must return exactly the requested number of bytes."""
        source = MockUniformSource(mean=127.5)
        for count in (1, 100, 20480):
            data = source.get_bytes(count)
            assert len(data) == count

    def test_mean_near_configured_value(self) -> None:
        """The byte values should average near the configured mean.

        With 20,480 samples, the sample mean should be very close to
        the configured mean (within ±2 for typical std).
        """
        target_mean = 130.0
        source = MockUniformSource(mean=target_mean, seed=42)
        data = source.get_bytes(20480)
        samples = np.frombuffer(data, dtype=np.uint8)
        # Clipping distorts the mean slightly near boundaries,
        # but 130 is far enough from 0 and 255 that the effect is small.
        assert float(samples.mean()) == pytest.approx(target_mean, abs=2.0)

    def test_default_mean(self) -> None:
        """Default mean is 127.5 (null hypothesis)."""
        source = MockUniformSource(seed=42)
        data = source.get_bytes(20480)
        samples = np.frombuffer(data, dtype=np.uint8)
        assert float(samples.mean()) == pytest.approx(127.5, abs=2.0)

    def test_reproducibility_with_seed(self) -> None:
        """Same seed produces identical output."""
        source_a = MockUniformSource(mean=127.5, seed=12345)
        source_b = MockUniformSource(mean=127.5, seed=12345)
        assert source_a.get_bytes(1000) == source_b.get_bytes(1000)

    def test_different_seeds_differ(self) -> None:
        """Different seeds produce different output."""
        source_a = MockUniformSource(mean=127.5, seed=1)
        source_b = MockUniformSource(mean=127.5, seed=2)
        assert source_a.get_bytes(1000) != source_b.get_bytes(1000)

    def test_bytes_in_valid_range(self) -> None:
        """All generated bytes must be in [0, 255] (uint8)."""
        source = MockUniformSource(mean=250.0, seed=42)
        data = source.get_bytes(10000)
        samples = np.frombuffer(data, dtype=np.uint8)
        assert samples.min() >= 0
        assert samples.max() <= 255

    def test_health_check(self) -> None:
        """Health check reports source type and configured mean."""
        source = MockUniformSource(mean=130.0)
        health = source.health_check()
        assert health["source"] == "mock_uniform"
        assert health["healthy"] is True
        assert health["configured_mean"] == 130.0

    def test_prefetch_is_noop(self) -> None:
        """Prefetch should not raise — it's a no-op."""
        source = MockUniformSource(mean=127.5)
        source.prefetch(20480)  # Should not raise


# ---------------------------------------------------------------------------
# FallbackEntropySource
# ---------------------------------------------------------------------------


class _FailingSource(EntropySource):
    """A test source that always raises EntropyUnavailableError."""

    def get_bytes(self, count: int) -> bytes:
        raise EntropyUnavailableError("test: primary always fails")

    def prefetch(self, count: int) -> None:
        pass

    def health_check(self) -> dict:
        return {"source": "failing", "healthy": False}


class _ExplodingSource(EntropySource):
    """A test source that raises a non-EntropyUnavailableError exception."""

    def get_bytes(self, count: int) -> bytes:
        raise RuntimeError("unexpected internal error")

    def prefetch(self, count: int) -> None:
        pass

    def health_check(self) -> dict:
        return {"source": "exploding", "healthy": False}


class TestFallbackEntropySource:
    """Tests for the fallback wrapper pattern."""

    def test_uses_primary_when_healthy(self) -> None:
        """When primary succeeds, fallback is never called."""
        primary = OsUrandomSource()
        fallback = MockUniformSource(mean=127.5, seed=99)

        wrapper = FallbackEntropySource(primary, fallback)
        data = wrapper.get_bytes(100)

        assert len(data) == 100

    def test_falls_back_on_entropy_unavailable(self) -> None:
        """When primary raises EntropyUnavailableError, fallback is used."""
        primary = _FailingSource()
        fallback = MockUniformSource(mean=127.5, seed=42)

        wrapper = FallbackEntropySource(primary, fallback)
        data = wrapper.get_bytes(100)

        # Should have gotten data from the fallback.
        assert len(data) == 100

        # Verify it's actually from the fallback (same seed → same data).
        expected = MockUniformSource(mean=127.5, seed=42).get_bytes(100)
        assert data == expected

    def test_propagates_non_entropy_errors(self) -> None:
        """Non-EntropyUnavailableError exceptions are NOT caught.

        The wrapper must only catch EntropyUnavailableError. Other
        exceptions indicate programming bugs that must not be silenced.
        """
        primary = _ExplodingSource()
        fallback = MockUniformSource(mean=127.5, seed=42)

        wrapper = FallbackEntropySource(primary, fallback)

        with pytest.raises(RuntimeError, match="unexpected internal error"):
            wrapper.get_bytes(100)

    def test_prefetch_delegates_to_primary(self) -> None:
        """Prefetch is called on the primary source, not fallback."""
        primary = MagicMock(spec=EntropySource)
        fallback = MagicMock(spec=EntropySource)

        wrapper = FallbackEntropySource(primary, fallback)
        wrapper.prefetch(20480)

        primary.prefetch.assert_called_once_with(20480)
        fallback.prefetch.assert_not_called()

    def test_health_check_reports_both(self) -> None:
        """Health check includes both primary and fallback status."""
        primary = _FailingSource()
        fallback = OsUrandomSource()

        wrapper = FallbackEntropySource(primary, fallback)
        health = wrapper.health_check()

        assert health["source"] == "fallback_wrapper"
        assert health["primary"]["source"] == "failing"
        assert health["primary"]["healthy"] is False
        assert health["fallback"]["source"] == "os_urandom"
        assert health["fallback"]["healthy"] is True
        # Overall healthy if either is healthy.
        assert health["healthy"] is True

    def test_both_unhealthy(self) -> None:
        """If both primary and fallback are unhealthy, overall is unhealthy."""
        primary = _FailingSource()
        fallback = _FailingSource()

        wrapper = FallbackEntropySource(primary, fallback)
        health = wrapper.health_check()

        assert health["healthy"] is False

    def test_both_fail_raises_from_fallback(self) -> None:
        """If both primary and fallback raise, the fallback's error propagates."""
        primary = _FailingSource()
        fallback = _FailingSource()

        wrapper = FallbackEntropySource(primary, fallback)

        with pytest.raises(EntropyUnavailableError):
            wrapper.get_bytes(100)

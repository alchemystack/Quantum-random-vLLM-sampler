"""Tests for TimingNoiseSource."""

from __future__ import annotations

import warnings

import pytest

from qr_sampler.entropy.timing import TimingNoiseSource


class TestTimingNoiseSource:
    """Tests for the CPU timing jitter entropy source."""

    def test_name(self) -> None:
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", UserWarning)
            source = TimingNoiseSource()
        assert source.name == "timing_noise"

    def test_is_always_available(self) -> None:
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", UserWarning)
            source = TimingNoiseSource()
        assert source.is_available is True

    def test_emits_warning_on_creation(self) -> None:
        with pytest.warns(UserWarning, match="experimental"):
            TimingNoiseSource()

    def test_returns_correct_byte_count(self) -> None:
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", UserWarning)
            source = TimingNoiseSource()
        # Only test small counts â€” timing entropy is slow.
        for n in (0, 1, 2, 4):
            data = source.get_random_bytes(n)
            assert len(data) == n

    def test_returns_bytes_type(self) -> None:
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", UserWarning)
            source = TimingNoiseSource()
        data = source.get_random_bytes(2)
        assert isinstance(data, bytes)

    def test_produces_some_output(self) -> None:
        """Generated bytes should be a valid bytes object of the right length."""
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", UserWarning)
            source = TimingNoiseSource()
        # On some platforms (Windows), the timer resolution may be low,
        # so we only verify length and type, not that values are non-zero.
        data = source.get_random_bytes(4)
        assert isinstance(data, bytes)
        assert len(data) == 4

    def test_close_is_noop(self) -> None:
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", UserWarning)
            source = TimingNoiseSource()
        source.close()  # Should not raise.

    def test_health_check(self) -> None:
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", UserWarning)
            source = TimingNoiseSource()
        health = source.health_check()
        assert health["source"] == "timing_noise"
        assert health["healthy"] is True

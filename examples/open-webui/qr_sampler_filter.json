[
  {
    "id": "qr_sampler_parameters",
    "name": "QR-Sampler Parameters",
    "meta": {
      "description": "Injects qr-sampler per-request parameters into vLLM requests. Configure sampling parameters via Valves to control external-entropy-driven token selection.",
      "manifest": {
        "title": "QR-Sampler Parameters",
        "author": "qr-sampler",
        "version": "0.1.0",
        "license": "MIT"
      }
    },
    "content": "\"\"\"\ntitle: QR-Sampler Parameters\nauthor: qr-sampler\nauthor_url: https://github.com/your-org/qr-sampler\nversion: 0.1.0\nlicense: MIT\ndescription: Injects qr-sampler per-request parameters into vLLM requests. Configure sampling parameters via Valves to control external-entropy-driven token selection.\n\"\"\"\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Filter:\n    \"\"\"Open WebUI filter that injects qr_* parameters into vLLM requests.\n\n    When qr-sampler is loaded as a vLLM logits processor, it reads per-request\n    overrides from extra fields in the request body (prefixed with ``qr_``).\n    This filter adds those fields via the ``inlet()`` hook so that Open WebUI\n    users can control sampling parameters through the Valves UI without\n    manually editing API calls.\n\n    Parameter flow::\n\n        Open WebUI chat -> inlet() adds qr_* keys -> vLLM /v1/chat/completions\n        -> SamplingParams.extra_args -> qr-sampler resolve_config()\n\n    Toggle ``enable_qr_sampling`` to False to disable parameter injection\n    entirely (requests pass through unmodified).\n    \"\"\"\n\n    class Valves(BaseModel):\n        \"\"\"Admin-configurable qr-sampler parameters.\n\n        Each field maps to a ``qr_*`` key that qr-sampler's\n        ``resolve_config()`` accepts. Only per-request-overridable fields\n        are exposed here; infrastructure settings (gRPC address, fallback\n        mode, etc.) are controlled by environment variables on the vLLM\n        container.\n        \"\"\"\n\n        # --- Filter control ---\n        priority: int = Field(\n            default=0,\n            description=\"Filter execution priority (lower runs first).\",\n        )\n        enable_qr_sampling: bool = Field(\n            default=True,\n            description=(\n                \"Master switch. When False, no qr_* parameters are injected \"\n                \"and requests pass through unmodified.\"\n            ),\n        )\n\n        # --- Token selection ---\n        top_k: int = Field(\n            default=50,\n            description=\"Top-k filtering: keep only the k most probable tokens (0 disables).\",\n        )\n        top_p: float = Field(\n            default=0.9,\n            description=\"Nucleus sampling threshold (1.0 disables).\",\n        )\n\n        # --- Temperature ---\n        temperature_strategy: str = Field(\n            default=\"fixed\",\n            description=\"Temperature strategy: 'fixed' or 'edt' (entropy-dependent).\",\n        )\n        fixed_temperature: float = Field(\n            default=0.7,\n            description=\"Constant temperature when strategy is 'fixed'.\",\n        )\n        edt_base_temp: float = Field(\n            default=0.8,\n            description=\"Base coefficient for EDT strategy.\",\n        )\n        edt_exponent: float = Field(\n            default=0.5,\n            description=\"Power-law exponent for EDT strategy.\",\n        )\n        edt_min_temp: float = Field(\n            default=0.1,\n            description=\"EDT temperature floor.\",\n        )\n        edt_max_temp: float = Field(\n            default=2.0,\n            description=\"EDT temperature ceiling.\",\n        )\n\n        # --- Signal amplification ---\n        signal_amplifier_type: str = Field(\n            default=\"zscore_mean\",\n            description=\"Signal amplification algorithm.\",\n        )\n        sample_count: int = Field(\n            default=20480,\n            description=\"Number of entropy bytes to fetch per token.\",\n        )\n        population_mean: float = Field(\n            default=127.5,\n            description=\"Null-hypothesis mean of byte values {0..255}.\",\n        )\n        population_std: float = Field(\n            default=73.61215932167728,\n            description=\"Population std for continuous uniform [0, 255].\",\n        )\n        uniform_clamp_epsilon: float = Field(\n            default=1e-10,\n            description=\"Clamp u to (epsilon, 1-epsilon) to avoid degenerate CDF.\",\n        )\n\n        # --- Logging ---\n        log_level: str = Field(\n            default=\"summary\",\n            description=\"Logging verbosity: 'none', 'summary', or 'full'.\",\n        )\n        diagnostic_mode: bool = Field(\n            default=False,\n            description=\"Store all token records in memory for analysis.\",\n        )\n\n    def __init__(self) -> None:\n        self.valves = self.Valves()\n\n    # Fields that are part of qr-sampler config (everything except filter-\n    # internal fields like ``priority`` and ``enable_qr_sampling``).\n    _QR_FIELDS: frozenset = frozenset(\n        {\n            \"signal_amplifier_type\",\n            \"sample_count\",\n            \"population_mean\",\n            \"population_std\",\n            \"uniform_clamp_epsilon\",\n            \"temperature_strategy\",\n            \"fixed_temperature\",\n            \"edt_base_temp\",\n            \"edt_exponent\",\n            \"edt_min_temp\",\n            \"edt_max_temp\",\n            \"top_k\",\n            \"top_p\",\n            \"log_level\",\n            \"diagnostic_mode\",\n        }\n    )\n\n    async def inlet(\n        self,\n        body: dict,\n        __user__: Optional[dict] = None,\n    ) -> dict:\n        \"\"\"Inject qr_* parameters into the request body before it reaches vLLM.\n\n        Each Valve value is added as a top-level ``qr_<field>`` key.  vLLM\n        maps unknown top-level keys to ``SamplingParams.extra_args``, and\n        qr-sampler's ``resolve_config()`` picks them up from there.\n\n        Args:\n            body: The request body (messages, model, stream, etc.).\n            __user__: Optional user information from Open WebUI.\n\n        Returns:\n            The request body with qr_* keys injected (or unmodified if\n            sampling is disabled).\n        \"\"\"\n        if not self.valves.enable_qr_sampling:\n            return body\n\n        valve_dict = self.valves.model_dump()\n        for field_name in self._QR_FIELDS:\n            body[f\"qr_{field_name}\"] = valve_dict[field_name]\n\n        return body\n\n    async def outlet(\n        self,\n        body: dict,\n        __user__: Optional[dict] = None,\n    ) -> dict:\n        \"\"\"Pass-through â€” no post-processing needed.\n\n        Args:\n            body: The response body from vLLM.\n            __user__: Optional user information from Open WebUI.\n\n        Returns:\n            The response body unmodified.\n        \"\"\"\n        return body\n"
  }
]
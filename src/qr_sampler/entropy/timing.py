"""CPU timing jitter entropy source (experimental).

Derives entropy from variations in instruction execution timing. Each byte
is generated by timing a series of hash operations and extracting the
least-significant bits of the nanosecond timing deltas.

.. warning::

    This source is **experimental and educational**. Timing noise is
    deterministic under classical physics — it is not suitable for
    consciousness-research experiments that require true quantum randomness.
    Use for testing, demos, and as an example of a non-gRPC entropy source.
"""

from __future__ import annotations

import hashlib
import logging
import time
import warnings

from qr_sampler.entropy.base import EntropySource
from qr_sampler.entropy.registry import register_entropy_source

logger = logging.getLogger("qr_sampler")

_BITS_PER_BYTE = 8
_HASH_ITERATIONS = 64


@register_entropy_source("timing_noise")
class TimingNoiseSource(EntropySource):
    """CPU timing jitter entropy source.

    Derives entropy from variations in instruction execution timing.
    Each byte is generated by timing a series of operations and
    extracting the least-significant bits of the timing deltas.

    Warning:
        This is EXPERIMENTAL. Not suitable for consciousness-research
        experiments (timing noise is deterministic under classical physics).
        Useful for testing, demos, and as an example of a non-gRPC source.
    """

    def __init__(self) -> None:
        warnings.warn(
            "TimingNoiseSource is experimental. Timing jitter is not quantum-random "
            "and should not be used for consciousness-research experiments.",
            stacklevel=2,
            category=UserWarning,
        )

    @property
    def name(self) -> str:
        """Return ``'timing_noise'``."""
        return "timing_noise"

    @property
    def is_available(self) -> bool:
        """Always returns ``True`` — CPU timing is always available."""
        return True

    def get_random_bytes(self, n: int) -> bytes:
        """Generate *n* bytes from CPU timing jitter.

        Algorithm:
            1. For each byte, perform 8 timing measurements.
            2. Each measurement times a tight loop of hash operations.
            3. Extract the LSB of the nanosecond delta.
            4. Combine 8 bits into one byte.

        Args:
            n: Number of random bytes to generate.

        Returns:
            Exactly *n* bytes derived from CPU timing jitter.
        """
        result = bytearray(n)
        for i in range(n):
            byte_val = 0
            for bit in range(_BITS_PER_BYTE):
                t0 = time.perf_counter_ns()
                # Tight computation loop — timing varies with CPU state.
                h = hashlib.sha256(b"timing_noise")
                for _ in range(_HASH_ITERATIONS):
                    h = hashlib.sha256(h.digest())
                t1 = time.perf_counter_ns()
                delta = t1 - t0
                # Extract LSB of nanosecond delta.
                byte_val |= (delta & 1) << bit
            result[i] = byte_val
        return bytes(result)

    def close(self) -> None:
        """No-op — no resources to release."""
